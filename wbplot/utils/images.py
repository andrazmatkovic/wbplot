import numpy as np
import nibabel as nib
from numpy import ndarray
from .. import constants, config
from . import plots
from os.path import sep, join
import xml.etree.cElementTree as eT
from matplotlib import colors as clrs
from matplotlib import cm

# Uncomment the line below to suppress console statements generated by nibabel
# nib.imageglobals.logger.disabled = True


def write_parcellated_image(pscalars, fout, hemisphere=None, vrange=None,
                            cmap=None):
    """
    Insert parcellated scalars into a dlabel file.

    Parameters
    ----------
    pscalars : numpy.ndarray
    fout : str
    hemisphere : 'left' or 'right' or None, default None
        which hemisphere `pscalars` correspond to. for bilateral data use None
    vrange : tuple
    cmap : str

    Returns
    -------
    None

    Notes
    -----
    This function assumes that the ordering of parcels... TODO

    """
    check_hemisphere(hemisphere=hemisphere)
    pscalars_lr = map_unilateral_to_bilateral(
        pscalars=pscalars, hemisphere=hemisphere)
    c = Cifti(constants.DLABEL_FILE)
    c.set_cmap(data=pscalars_lr, cmap=cmap, vrange=vrange)
    c.save(fout=fout)
    return


def map_unilateral_to_bilateral(pscalars, hemisphere):
    """

    Parameters
    ----------
    pscalars : numpy.ndarray
        unilateral parcellated scalars
    hemisphere : 'left' or 'right' or None

    Returns
    -------
    numpy.ndarray
        bilateral pscalars, with contralateral hemisphere padded with zeros

    """
    hemisphere = check_hemisphere(hemisphere=hemisphere)
    if hemisphere is None:
        return pscalars
    pscalars_lr = np.zeros(360)
    if hemisphere == 'right':
        pscalars_lr[180:] = pscalars
    elif hemisphere == 'left':
        pscalars_lr[:180] = pscalars
    return pscalars_lr


def check_hemisphere(hemisphere):
    """
    Check hemisphere argument for package compatibility.

    Parameters
    ----------
    hemisphere : 'left' or 'right' or None

    Returns
    -------
    'left' or 'right' or None

    """
    options = ['left', 'l', 'L', 'right', 'r', 'R', None, 'lr', 'LR']
    if hemisphere not in options:
        raise ValueError("{} if not a valid hemisphere".format(hemisphere))
    if hemisphere in ['left', 'l', 'L']:
        return 'left'
    if hemisphere in ['right', 'r', 'R']:
        return 'right'
    if hemisphere in ['None', 'lr', 'LR']:
        return None


def write_dense_image(dscalars, fname):

    """
    Save dense scalars to a NIFTI neuroimaging file for visualization in
    Connnectome Workbench.

    Parameters
    ----------
    dscalars : numpy.ndarray
        scalar vector of length config.constants.N_CIFTI_INDEX
    fname : str
        Output filename, saved to outputs directory w/ extension dscalar.nii

    Returns
    -------
    f : str
        absolute path to saved file

    """
    # TODO
    check_dscalars(dscalars)

    if sep in fname:
        fname = fname.split(sep)[-1]

    ext = ".dscalar.nii"
    if fname[-12:] != ext:
        assert ".nii" != fname[-4:] != ".gii"
        fname += ext

    new_data = np.copy(dscalars)

    # Load template NIFTI file (from which to create a new file)
    of = nib.load(constants.DSCALAR_FILE)

    # Load data from the template file
    temp_data = np.array(of.get_data())

    # Reshape the new data appropriately
    data_to_write = new_data.reshape(np.shape(temp_data))

    # Create and save a new NIFTI2 image object
    new_img = nib.Nifti2Image(
        data_to_write, affine=of.affine, header=of.header)
    f = join(config.OUTPUT_DIR, fname)
    nib.save(new_img, f)
    return f


# TODO : finish this; also rewrite as function?
class Cifti(object):

    def __init__(self, image_file):
        """

        Parameters
        ----------
        image_file : str
            absolute path to neuroimaging file

        """
        of = nib.load(image_file)
        self.data = of.get_data()
        self.affine = of.affine
        self.header = of.header
        self.extensions = eT.fromstring(self.header.extensions[0].get_content())
        self.vrange = None
        self.ischanged = False

    def set_cmap(self, data, cmap=None, vrange=None, mappable=None):
        """
        Map scalar data to RGB values using the provided colormap.

        Parameters
        ----------
        data : numpy.ndarray
        cmap : str
        vrange : tuple
        mappable

        Returns
        -------

        """

        cmap = plots.check_cmap(cmap)

        # Map data to colors
        if mappable is None:
            self.vrange = [data.min(), data.max()] if vrange is None else vrange
            cnorm = clrs.Normalize(vmin=self.vrange[0], vmax=self.vrange[1])
            clr_map = cm.ScalarMappable(cmap=cmap, norm=cnorm)
            colors = clr_map.to_rgba(data)
        else:
            colors = np.array([mappable(d) for d in data])

        # Set zero values (i.e., masked values) to grey
        greys = cm.get_cmap('Greys')
        nullmap = greys(0.2 * np.ones(np.sum(data == 0.0)))
        colors[data == 0.0, :] = nullmap

        for ii in range(1, len(self.extensions[0][1][0][1])):
            self.extensions[0][1][0][1][ii].set(
                'Red', str(colors[ii - 1, 0]))
            self.extensions[0][1][0][1][ii].set(
                'Green', str(colors[ii - 1, 1]))
            self.extensions[0][1][0][1][ii].set(
                'Blue', str(colors[ii - 1, 2]))
            self.extensions[0][1][0][1][ii].set(
                'Alpha', str(colors[ii - 1, 3]))
        self.ischanged = True

    def write_extensions(self):
        self.header.extensions[0].content = eT.tostring(self.extensions)

    def save(self, fout):
        """

        Parameters
        ----------
        fout : str
            absolute path to output file

        Returns
        -------
        None

        """
        if self.ischanged:
            self.write_extensions()
        new_img = nib.Nifti2Image(
            self.data, affine=self.affine, header=self.header)
        nib.save(new_img, fout)


def check_pscalars_unilateral(pscalars):
    """

    Parameters
    ----------
    pscalars : array_like
        parcellated scalars

    Returns
    -------
    None

    """
    if type(pscalars) is not ndarray:
        raise RuntimeError("pscalars must be a NumPy array")
    if pscalars.ndim != 1:
        raise RuntimeError("pscalars must be one-dimensional")
    if pscalars.size != 180:
        raise RuntimeError("unilateral pscalars must be length 180")


def check_pscalars_bilateral(pscalars):
    """

    Parameters
    ----------
    pscalars : array_like
        parcellated scalars

    Returns
    -------
    None

    """
    if type(pscalars) is not ndarray:
        raise RuntimeError("pscalars must be a NumPy array")
    if pscalars.ndim != 1:
        raise RuntimeError("pscalars must be one-dimensional")
    if pscalars.size != 360:
        raise RuntimeError("bilateral pscalars must be length 360")


def check_dscalars(dscalars):
    """

    Parameters
    ----------
    dscalars : numpy.ndarray
        dense scalars

    Returns
    -------
    None

    """
    if type(dscalars) is not ndarray:
        raise RuntimeError("dscalars must be a NumPy array")
    if dscalars.ndim != 1:
        raise RuntimeError("dscalars must be one-dimensional")
    if dscalars.size != 91282:
        raise RuntimeError("bilateral dscalars must be length 91282")
