from wbplot import config, constants
from wbplot.utils import plots, images
import nibabel as nib
import matplotlib.pyplot as plt
from matplotlib import colorbar
from matplotlib import colors
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
from os import system, remove, rename
from os.path import sep, join


# Uncomment the line below to suppress console statements generated by nibabel
# nib.imageglobals.logger.disabled = True


def pscalar(file_out, pscalars, vrange=None, scene_num=1, cmap=None,
            transparent=False):
    """

    Parameters
    ----------
    file_out : str
        absolute path to filename where image is saved
    pscalars : array_like
        parcel scalar values
    vrange : tuple, default None
        (min, max) of data for plotting
    scene_num : int, default 1
        3 for portrait, 1 for landscape (default 1)
    cmap : str or :class:`~matplotlib.colors.Colormap` instance, default None
        colormap to use for plotting.
    transparent : bool
        make all white pixels in map transparent

    Returns
    -------

    Notes
    -----
    For a list of available colormaps, see the wbplot.constants module or visit
    https://www.humanconnectome.org/software/workbench-command/-metric-palette.

    """

    cmap = plots.check_cmap(cmap)

    images.write_parcellated_image(
        pscalars=pscalars, fout=constants.DLABEL_FILE, vrange=vrange, cmap=cmap)
    # if scene_num == 1:
    #     width, height = constants.LANDSCAPE_SIZE
    # elif scene_num == 3:
    #     width, height = constants.PORTRAIT_SIZE
    # else:
    #     raise BaseException()

    cmd = 'wb_command -show-scene "{}" {} "{}" {} {}'.format(
        config.SCENE_FILE, scene_num, file_out, width, height)
    cmd += " >/dev/null 2>&1"
    system(cmd)

    if transparent:
        plots.make_transparent(file_out)


def save_workbench_image(dscalars, fname, scene=3, cortex_only=False,
                         cmap=None):

    """
    Save an image of dense scalars using Connnectome Workbench.

    Parameters
    ----------
    dscalars : array_like
        dense scalar vector of length config.constants.N_CIFTI_INDEX
    fname : str
        Output filename, saved to outputs directory with extension .png
    scene : int (2 or 3, optional)
        which scene to auto-generate; both include subcortical montages,
        but scene 3 includes flat cortical surface views and black background
        (default, 3)
    cortex_only : bool (optional)
        if True, mask subcortical parcels' expression values. Note that you
        may want to renormalize expression values if using this kwaarg (see
        lib.main.GeminiDot.renormalize)
    cmap : str (optional, default 'RY-BC-BL')
        color map. Defaults to 'RY-BC-BL' -- ie, red/yellow-black-blue, ideal
        for diverging colormaps. Can be any color map allowed by Connectome
        Workbench (see Notes). The recommended colormap for unidirectional data
        (ie, positive or negative definite) is `magma`.

    Returns
    -------
    f : str
        absolute path to saved file

    """

    cmap = plots.check_cmap(cmap)

    assert dscalars.size == 91282  # TODO

    if sep in fname:
        fname = fname.split(sep)[-1]

    ext = ".png"
    if fname[-4:] != ext:
        fname += ext

    if cortex_only:
        structures = ['CORTEX_LEFT', 'CORTEX_RIGHT']
        dscalars = __cifti.generate_structure_mask(
            structures=structures, weights=dscalars)

    new_data = np.copy(dscalars)

    # Load template NIFTI file (into which `dscalars` will be inserted)
    of = nib.load(constants.DSCALAR_FILE)

    # Load data from the template file
    temp_data = np.array(of.get_data())

    # # Overwrite existing template data with `dscalars`

    # First, write new data to existing template file
    data_to_write = new_data.reshape(np.shape(temp_data))
    new_img = nib.Nifti2Image(data_to_write, affine=of.affine, header=of.header)
    prefix = constants.DSCALAR_FILE.split(".dscalar.nii")[0]
    nib.save(new_img, constants.DSCALAR_FILE)

    # Use Workbench's command line utilities to change the color palette. Note
    # that this command requires saving to a new CIFTI file, which I will do
    # before overwriting the old file
    cifti_out = prefix + "_temp.dscalar.nii"
    cifti_in = constants.DSCALAR_FILE
    cmd = "wb_command -cifti-palette %s %s %s -palette-name %s" % (
        cifti_in, "MODE_AUTO_SCALE_PERCENTAGE", cifti_out, cmap)
    system(cmd)

    # Delete existing template file; rename new file to replace old template
    remove(cifti_in)
    rename(cifti_out, cifti_in)

    # Use Workbench's command line utilities and the provided scene template
    # file to auto-generate an output image
    fout = join(config.OUTPUT_DIR, fname)

    cmd = "wb_command -show-scene %s %i %s %i %i " % (
        constants.SCENE_FILE, scene, fout, width, height)

    system(cmd)

    return fout


def wb_cbar(cax, vrange, cmap, orientation='horizontal'):
    """

    Parameters
    ----------
    cax
    vrange
    cmap
    orientation

    Returns
    -------
    cbar : :class:colorbar.ColorbarBase
    """
    cnorm = colors.Normalize(vmin=vrange[0], vmax=vrange[1])
    cmap = plt.get_cmap(cmap)
    cbar = colorbar.ColorbarBase(
        cax, cmap=cmap, norm=cnorm, orientation=orientation)
    return cbar


def add_cmap(im, ax, ticks=None, top=True, pad=0.05, size=10, extend=None,
             lw=None):
    """

    Parameters
    ----------
    im
    ax
    ticks
    top
    pad
    size
    extend
    lw

    Returns
    -------

    """
    divider = make_axes_locatable(ax)
    if top:
        cax = divider.append_axes("top", size="{}%%".format(size), pad=pad)
        if extend is not None:
            cbar = plt.colorbar(
                im, cax=cax, orientation='horizontal', extend=extend)
        else:
            cbar = plt.colorbar(im, cax=cax, orientation='horizontal')
        cbar.ax.xaxis.set_ticks_position('top')
        cbar.ax.xaxis.set_label_position('top')
    else:
        cax = divider.append_axes("right", size="{}%%".format(size), pad=pad)
        if extend is not None:
            cbar = plt.colorbar(
                im, cax=cax, orientation='vertical', extend=extend)
        else:
            cbar = plt.colorbar(im, cax=cax, orientation='vertical')
    if ticks is not None:
        cbar.set_ticks(ticks)
    if lw is None:
        cbar.outline.set_visible(False)
    elif lw > 0:
        cbar.outline.set_linewidth(lw)
    return cax
